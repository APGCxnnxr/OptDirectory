<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Offline Game Launcher</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#f7f7fb; --card:#fff; --muted:#6b7280; --accent:#2563eb; }
    html,body{height:100%;margin:0;font-family:Inter, system-ui, Arial; background:var(--bg); color:#111}
    .app{display:flex;flex-direction:column;height:100vh}
    header{display:flex;align-items:center;gap:12px;padding:12px 16px;background:transparent;border-bottom:1px solid rgba(0,0,0,0.06)}
    .brand{font-weight:700}
    .controls{margin-left:auto;display:flex;gap:8px;align-items:center}
    button{background:var(--accent);color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
    button.ghost{background:transparent;color:var(--accent);border:1px solid rgba(37,99,235,0.18)}
    main{display:flex;flex:1;overflow:hidden}
    #home{padding:20px;flex:1;overflow:auto}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:16px}
    .tile{background:var(--card);border-radius:10px;padding:14px;box-shadow:0 1px 3px rgba(0,0,0,0.06);display:flex;flex-direction:column;gap:10px;align-items:start}
    .tile h3{margin:0;font-size:16px}
    .tile p{margin:0;color:var(--muted);font-size:13px}
    .thumb{height:120px;width:100%;background:linear-gradient(135deg,#eef2ff,#fff);border-radius:8px;display:flex;align-items:center;justify-content:center;color:var(--muted);font-weight:700}
    .row{display:flex;gap:8px;width:100%;justify-content:space-between}
    #player{flex:1;display:flex;flex-direction:column;align-items:stretch;background:#000}
    #gameHeader{display:flex;align-items:center;gap:12px;padding:10px 12px;background:#fff;border-bottom:1px solid rgba(0,0,0,0.06)}
    #gameFrame{flex:1;border:0;width:100%;background:#000}
    .muted{color:var(--muted);font-size:13px}
    footer{padding:8px 12px;border-top:1px solid rgba(0,0,0,0.06);font-size:13px;background:#fff}
    .small{font-size:13px;color:var(--muted)}
    .input{padding:6px;border-radius:6px;border:1px solid #ddd}
    .accountBox{display:flex;gap:8px;align-items:center}
    @media (max-width:640px){ .grid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">Offline Launcher</div>
      <div class="small">Embedded + local folder games</div>

      <div class="controls" id="controls">
        <div style="display:flex;gap:8px;align-items:center;margin-left:8px">
          <button id="pickFolderBtn" title="Select a folder of HTML games">Add folder</button>
          <button id="importFileBtn" title="Import a single HTML file">Import file</button>
          <button id="fullscreenBtn" title="Toggle fullscreen">Fullscreen</button>
          <button id="homeBtn" class="ghost" title="Back to home">Home</button>
        </div>
      </div>
    </header>

    <main>
      <!-- Home / tiles -->
      <section id="home" aria-label="Game library">
        <h2 style="margin-top:0">Games</h2>
        <div class="small" id="folderHint">No folder selected. Use "Add folder" to auto-discover games in a folder (Chromium only) or "Import file" to add a single game.</div>
        <div style="margin-top:12px;margin-bottom:12px">
          <label><input type="checkbox" id="autoScan"> Auto-scan folder (poll every 15s)</label>
        </div>
        <div class="grid" id="gamesGrid"></div>
      </section>

      <!-- Player area (hidden when on home) -->
      <section id="player" style="display:none" aria-label="Game player">
        <div id="gameHeader">
          <strong id="gameTitle">Game</strong>
          <div style="flex:1"></div>
          <div class="muted" id="gameHint">Click Fullscreen to expand</div>
        </div>
        <!-- sandbox includes allow-same-origin so scripts and postMessage work for blob URLs -->
        <iframe id="gameFrame" sandbox="allow-scripts allow-same-origin allow-forms allow-modals" allow="fullscreen"></iframe>
        <footer>
          <button id="backBtn" class="ghost">Back to games</button>
          <span style="margin-left:10px" id="saveStatus" class="muted"></span>
        </footer>
      </section>
    </main>
  </div>

  <input id="fileInput" type="file" accept="text/html" style="display:none" />

  <script>
  // Simplified & fixed importer
  const SCAN_POLL_INTERVAL = 15000;

  // Built-in example games for the grid (kept short)
  const BUILT_IN_GAMES = [
    { id:'counter', name:'Counter Clicker', desc:'Click to increase a counter, save/load via launcher.',
      srcdoc:`<!doctype html><meta charset="utf-8"><title>Counter</title>
<style>body{font-family:system-ui;padding:20px}button{padding:8px 12px}</style>
<h2>Counter</h2><div>Count: <span id="c">0</span></div>
<button id="inc">+1</button><button id="save">Save</button><button id="load">Load</button>
<script>
let count=0;const el=document.getElementById('c');
document.getElementById('inc').onclick=()=>{count++; el.textContent=count;}
document.getElementById('save').onclick=()=> parent.postMessage({type:'launcher.save', slot:'default', data:{count}}, '*');
document.getElementById('load').onclick=()=> parent.postMessage({type:'launcher.load', slot:'default', requestId:'r'+Date.now()}, '*');
window.addEventListener('message',(e)=>{ const m=e.data||{}; if(m.type==='launcher.init'){ if(m.saves && m.saves.default){ count=m.saves.default.count||0; el.textContent=count; } } if(m.type==='launcher.load.response'){ if(m.data){ count=m.data.count||0; el.textContent=count; } } });
</script>` },
    // (other built-ins omitted for brevity in the source list; they will still be shown)
  ];

  // State & DOM refs
  const games = []; // entries from folder or imports: { source:'file'|'folder', id, name, fileKey?, fileHandle?, fileName? }
  let folderHandle = null;
  let autoScanTimer = null;
  let currentGame = null;
  let coinIntervalTimer = null;

  const gamesGrid = document.getElementById('gamesGrid');
  const home = document.getElementById('home');
  const player = document.getElementById('player');
  const gameFrame = document.getElementById('gameFrame');
  const gameTitle = document.getElementById('gameTitle');
  const homeBtn = document.getElementById('homeBtn');
  const backBtn = document.getElementById('backBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const saveStatus = document.getElementById('saveStatus');
  const pickFolderBtn = document.getElementById('pickFolderBtn');
  const importFileBtn = document.getElementById('importFileBtn');
  const fileInput = document.getElementById('fileInput');
  const folderHint = document.getElementById('folderHint');
  const autoScanBox = document.getElementById('autoScan');

  const SAVE_KEY = 'launcher_saves';
  const META_DB = 'launcher-meta-db';
  const META_STORE = 'meta';
  const FOLDER_KEY = 'folder-handle';

  // ---- IDB helpers ----
  function idbOpen(){
    return new Promise((resolve,reject)=>{
      const r = indexedDB.open(META_DB, 1);
      r.onupgradeneeded = e => { const db=e.target.result; if(!db.objectStoreNames.contains(META_STORE)) db.createObjectStore(META_STORE); };
      r.onsuccess = e => resolve(e.target.result);
      r.onerror = e => reject(e.target.error);
    });
  }
  async function idbPut(key, val){
    const db = await idbOpen();
    return new Promise((res,rej)=>{
      const tx = db.transaction(META_STORE,'readwrite'); tx.objectStore(META_STORE).put(val,key);
      tx.oncomplete = ()=>res();
      tx.onerror = e=>rej(e.target.error);
    });
  }
  async function idbGet(key){
    const db = await idbOpen();
    return new Promise((res,rej)=>{
      const tx=db.transaction(META_STORE,'readonly'); const r=tx.objectStore(META_STORE).get(key);
      r.onsuccess = e=>res(e.target.result);
      r.onerror = e=>rej(e.target.error);
    });
  }
  async function idbDelete(key){
    const db = await idbOpen();
    return new Promise((res,rej)=>{
      const tx = db.transaction(META_STORE,'readwrite'); tx.objectStore(META_STORE).delete(key);
      tx.oncomplete = ()=>res();
      tx.onerror = e=>rej(e.target.error);
    });
  }
  async function idbGetAllEntries(){
    const db = await idbOpen();
    return new Promise((res,rej)=>{
      const tx = db.transaction(META_STORE,'readonly'); const store = tx.objectStore(META_STORE);
      const req = store.getAll();
      req.onsuccess = e => res(e.target.result);
      req.onerror = e => rej(e.target.error);
    });
  }

  // ---- saves helpers ----
  function loadSaves(){ try { return JSON.parse(localStorage.getItem(SAVE_KEY)) || {}; } catch(e){ return {}; } }
  function saveSaves(obj){ localStorage.setItem(SAVE_KEY, JSON.stringify(obj)); }

  // ---- Import single file (fixed) ----
  // We store imported files as records: { type:'import', name, blob } keyed by 'import-<timestamp>-<name>'
  async function importSingleFile(file){
    try {
      const blob = new Blob([await file.arrayBuffer()], { type: 'text/html' });
      const key = 'import-' + Date.now() + '-' + file.name;
      const rec = { type:'import', name: file.name, blob };
      await idbPut(key, rec);
      games.push({ source:'file', id:key, name:file.name, fileKey:key });
      renderTiles();
    } catch(err){
      console.error('importSingleFile failed', err);
      alert('Import failed: ' + err);
    }
  }

  // load imported files at startup
  async function loadImportedFiles(){
    try {
      const entries = await idbGetAllEntries();
      for (const entryKey in entries) { /* no-op to appease some linters */ }
      // entries is an array of records (values). We need keys as well, but getAll returns values only.
      // We'll instead iterate over keys separately to associate keys with values:
      const db = await idbOpen();
      const tx = db.transaction(META_STORE,'readonly'); const store = tx.objectStore(META_STORE);
      const req = store.getAllKeys();
      const keys = await new Promise((res,rej)=>{ req.onsuccess = e=>res(e.target.result); req.onerror = e=>rej(e.target.error); });
      for (const key of keys) {
        if (String(key).startsWith('import-')) {
          const rec = await new Promise((res,rej)=>{ const r = store.get(key); r.onsuccess = e=>res(e.target.result); r.onerror = e=>rej(e.target.error); });
          if (rec && rec.type === 'import' && rec.blob) {
            games.push({ source:'file', id:key, name:rec.name, fileKey:key });
          }
        }
      }
      renderTiles();
    } catch(err){ console.warn('loadImportedFiles failed', err); }
  }

  // ---- Folder picker (optional) ----
  async function pickFolder(){
    if(!window.showDirectoryPicker) { alert('Folder access not supported in this browser. Use Import file to add individual games.'); return; }
    try {
      const handle = await window.showDirectoryPicker();
      await idbPut(FOLDER_KEY, handle);
      folderHandle = handle;
      folderHint.textContent = 'Folder selected: ' + (handle.name || 'selected folder');
      await scanFolder();
    } catch(err){ console.error(err); }
  }

  async function loadStoredFolder(){
    try {
      const stored = await idbGet(FOLDER_KEY);
      if (stored) {
        folderHandle = stored;
        const perm = await folderHandle.queryPermission({ mode:'read' });
        if (perm === 'granted' || (await folderHandle.requestPermission({ mode:'read' }) ) === 'granted') {
          folderHint.textContent = 'Folder: ' + (folderHandle.name || 'selected');
          await scanFolder();
        } else {
          folderHint.textContent = 'Folder stored but permission not granted. Click "Add folder" to re-grant.';
          folderHandle = null;
        }
      }
    } catch(e){ console.warn('no stored folder', e); }
  }

  async function scanFolder(){
    if(!folderHandle) return;
    for(let i = games.length-1; i>=0; i--) if(games[i].source==='folder') games.splice(i,1);
    try {
      for await (const [name, handle] of folderHandle.entries()) {
        if (handle.kind === 'file' && name.match(/\.html?$/i)) {
          const id = 'file-' + name;
          games.push({ source:'folder', id, name, fileHandle: handle, fileName: name });
        }
      }
      renderTiles();
    } catch(err){ console.error('scanFolder failed', err); }
  }

  // ---- Render tiles ----
  function renderTiles(){
    gamesGrid.innerHTML = '';
    const list = [];
    for (const b of BUILT_IN_GAMES) list.push({ source:'builtin', ...b });
    for (const g of games) list.push(g);

    if (list.length === 0) {
      gamesGrid.innerHTML = '<div style="color:#666">No games found. Add a folder or import files.</div>';
      return;
    }

    for (const g of list) {
      const el = document.createElement('div');
      el.className = 'tile';
      const title = g.name || g.fileName || g.id;
      const desc = g.desc || (g.fileName ? 'Imported HTML file' : '');
      const thumbText = title.split(' ').slice(0,2).join(' ');
      el.innerHTML = `<div class="thumb">${escapeHtml(thumbText)}</div>
        <h3>${escapeHtml(title)}</h3>
        <p>${escapeHtml(desc)}</p>
        <div class="row"><div class="muted">ID: ${escapeHtml(g.id)}</div><div>
        <button data-id="${g.id}" data-src="${g.source}" class="play">Play</button>
        ${g.source==='file'?'<button class="remove" data-id="'+g.id+'">Remove</button>':''}
        </div></div>`;
      gamesGrid.appendChild(el);
    }

    gamesGrid.querySelectorAll('.play').forEach(b => b.addEventListener('click', e => {
      const id = e.currentTarget.getAttribute('data-id');
      const src = e.currentTarget.getAttribute('data-src');
      openGame(id, src);
    }));
    gamesGrid.querySelectorAll('.remove').forEach(b => b.addEventListener('click', async e => {
      const id = e.currentTarget.getAttribute('data-id');
      if (!confirm('Remove imported file?')) return;
      await idbDelete(id);
      for(let i=games.length-1;i>=0;i--) if(games[i].id===id) games.splice(i,1);
      renderTiles();
    }));
  }

  function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]); }

  // ---- Open game (handles builtins, imported files and folder files) ----
  async function openGame(id, source){
    // built-in
    const builtin = BUILT_IN_GAMES.find(x=>x.id===id);
    if (source === 'builtin' || builtin) {
      const entry = builtin;
      currentGame = { source:'builtin', id:entry.id, name:entry.name, srcdoc:entry.srcdoc };
      showPlayer();
      gameFrame.srcdoc = entry.srcdoc;
      return;
    }
    // imported or folder
    const entry = games.find(x=>x.id===id);
    if (!entry) { alert('Game not found'); return; }

    if (entry.source === 'folder') {
      try {
        const file = await entry.fileHandle.getFile();
        const text = await file.text();
        currentGame = { source:'folder', id:entry.id, name:entry.fileName, html:text };
        showPlayer();
        const blob = new Blob([text], { type:'text/html' });
        const url = URL.createObjectURL(blob);
        currentGame.blobUrl = url;
        gameFrame.src = url;
      } catch(err){ alert('Failed to load file: '+err); }
      return;
    }

    if (entry.source === 'file') {
      try {
        const db = await idbOpen();
        const tx = db.transaction(META_STORE,'readonly'); const store = tx.objectStore(META_STORE);
        const rec = await new Promise((res,rej)=>{ const r=store.get(entry.fileKey); r.onsuccess = e=>res(e.target.result); r.onerror = e=>rej(e.target.error); });
        if (rec && rec.type === 'import' && rec.blob) {
          const blob = rec.blob;
          const url = URL.createObjectURL(blob);
          currentGame = { source:'file', id:entry.id, name:entry.name, blobUrl: url };
          showPlayer();
          gameFrame.src = url;
        } else { alert('Imported file missing'); }
      } catch(err){ alert('Failed to load imported file: '+err); }
      return;
    }
  }

  function showPlayer(){
    home.style.display = 'none';
    player.style.display = 'flex';
    gameTitle.textContent = currentGame.name || currentGame.id;
    saveStatus.textContent = '';
  }
  function showHome(){
    if(currentGame && currentGame.blobUrl) { try{ URL.revokeObjectURL(currentGame.blobUrl); }catch(e){} }
    currentGame = null;
    home.style.display = 'block';
    player.style.display = 'none';
    gameFrame.src = 'about:blank';
  }

  // ---- Messaging (save/load) ----
  gameFrame.addEventListener('load', ()=>{
    if (!currentGame) return;
    const saves = loadSaves();
    const gid = currentGame.id;
    const gameSaves = (saves[gid] || {});
    postToFrame({ type:'launcher.init', saves: gameSaves, gameId: gid });
  });

  window.addEventListener('message', (ev)=>{
    const msg = ev.data || {};
    if (!msg || typeof msg !== 'object') return;
    if (msg.type === 'launcher.save') {
      const gid = msg.gameId || (currentGame && currentGame.id);
      if (!gid) return;
      const saves = loadSaves();
      saves[gid] = saves[gid] || {};
      const slot = msg.slot || 'default';
      saves[gid][slot] = msg.data;
      saveSaves(saves);
      postToFrame({ type:'launcher.save.ack', slot, gameId: gid });
      saveStatus.textContent = 'Saved';
      setTimeout(()=>{ if (saveStatus.textContent === 'Saved') saveStatus.textContent=''; }, 2000);
    } else if (msg.type === 'launcher.load') {
      const gid = msg.gameId || (currentGame && currentGame.id);
      if (!gid) return;
      const saves = loadSaves();
      const val = (saves[gid] && saves[gid][msg.slot || 'default']) || null;
      postToFrame({ type:'launcher.load.response', slot: msg.slot || 'default', data: val, requestId: msg.requestId || null, gameId: gid });
    }
  });

  function postToFrame(message){
    try { gameFrame.contentWindow.postMessage(message, '*'); } catch(e) {}
  }

  // ---- UI handlers ----
  homeBtn.addEventListener('click', showHome);
  backBtn.addEventListener('click', showHome);
  fullscreenBtn.addEventListener('click', async ()=>{
    if (!document.fullscreenElement) {
      try { await gameFrame.requestFullscreen(); } catch(err){ alert('Fullscreen failed: ' + err); }
    } else { await document.exitFullscreen(); }
  });

  pickFolderBtn.addEventListener('click', pickFolder);
  importFileBtn.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', async (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    await importSingleFile(f);
    fileInput.value = '';
  });

  autoScanBox.addEventListener('change', (e)=> {
    if (e.target.checked) startAutoScan(); else stopAutoScan();
  });

  async function startAutoScan(){
    if (autoScanTimer) clearInterval(autoScanTimer);
    autoScanTimer = setInterval(async ()=>{ if (folderHandle) await scanFolder(); }, SCAN_POLL_INTERVAL);
  }
  function stopAutoScan(){ if (autoScanTimer) { clearInterval(autoScanTimer); autoScanTimer = null; } }

  // startup
  (async function init(){
    await loadImportedFiles();
    await loadStoredFolder();
    renderTiles();
    const auto = localStorage.getItem('launcher_auto_scan') === '1';
    autoScanBox.checked = auto;
    if (auto) startAutoScan();
  })();

  autoScanBox.addEventListener('change', ()=> localStorage.setItem('launcher_auto_scan', autoScanBox.checked ? '1' : '0'));

  // Escape handling
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape') {
      if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
      else if (currentGame) showHome();
    }
  });
  </script>
</body>
</html>